THREE.EffectComposer=function(a,b){if(this.renderer=a,void 0===b){var c={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat,stencilBuffer:!1},d=a.getSize();b=new THREE.WebGLRenderTarget(d.width,d.height,c)}this.renderTarget1=b,this.renderTarget2=b.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2,this.passes=[],void 0===THREE.CopyShader&&console.error("THREE.EffectComposer relies on THREE.CopyShader"),this.copyPass=new THREE.ShaderPass(THREE.CopyShader)},Object.assign(THREE.EffectComposer.prototype,{swapBuffers:function(){var a=this.readBuffer;this.readBuffer=this.writeBuffer,this.writeBuffer=a},addPass:function(a){this.passes.push(a);var b=this.renderer.getSize();a.setSize(b.width,b.height)},insertPass:function(a,b){this.passes.splice(b,0,a)},render:function(a){var c,d,b=!1,e=this.passes.length;for(d=0;d<e;d++)if(c=this.passes[d],!1!==c.enabled){if(c.render(this.renderer,this.writeBuffer,this.readBuffer,a,b),c.needsSwap){if(b){var f=this.renderer.context;f.stencilFunc(f.NOTEQUAL,1,4294967295),this.copyPass.render(this.renderer,this.writeBuffer,this.readBuffer,a),f.stencilFunc(f.EQUAL,1,4294967295)}this.swapBuffers()}void 0!==THREE.MaskPass&&(c instanceof THREE.MaskPass?b=!0:c instanceof THREE.ClearMaskPass&&(b=!1))}},reset:function(a){if(void 0===a){var b=this.renderer.getSize();a=this.renderTarget1.clone(),a.setSize(b.width,b.height)}this.renderTarget1.dispose(),this.renderTarget2.dispose(),this.renderTarget1=a,this.renderTarget2=a.clone(),this.writeBuffer=this.renderTarget1,this.readBuffer=this.renderTarget2},setSize:function(a,b){this.renderTarget1.setSize(a,b),this.renderTarget2.setSize(a,b);for(var c=0;c<this.passes.length;c++)this.passes[c].setSize(a,b)}}),THREE.Pass=function(){this.enabled=!0,this.needsSwap=!0,this.clear=!1,this.renderToScreen=!1},Object.assign(THREE.Pass.prototype,{setSize:function(a,b){},render:function(a,b,c,d,e){console.error("THREE.Pass: .render() must be implemented in derived pass.")}});
THREE.RenderPass=function(a,b,c,d,e){THREE.Pass.call(this),this.scene=a,this.camera=b,this.overrideMaterial=c,this.clearColor=d,this.clearAlpha=void 0!==e?e:0,this.clear=!0,this.clearDepth=!1,this.needsSwap=!1},THREE.RenderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.RenderPass,render:function(a,b,c,d,e){var f=a.autoClear;a.autoClear=!1,this.scene.overrideMaterial=this.overrideMaterial;var g,h;this.clearColor&&(g=a.getClearColor().getHex(),h=a.getClearAlpha(),a.setClearColor(this.clearColor,this.clearAlpha)),this.clearDepth&&a.clearDepth(),a.render(this.scene,this.camera,this.renderToScreen?null:c,this.clear),this.clearColor&&a.setClearColor(g,h),this.scene.overrideMaterial=null,a.autoClear=f}});
THREE.ShaderPass=function(a,b){THREE.Pass.call(this),this.textureID=void 0!==b?b:"tDiffuse",a instanceof THREE.ShaderMaterial?(this.uniforms=a.uniforms,this.material=a):a&&(this.uniforms=THREE.UniformsUtils.clone(a.uniforms),this.material=new THREE.ShaderMaterial({defines:a.defines||{},uniforms:this.uniforms,vertexShader:a.vertexShader,fragmentShader:a.fragmentShader})),this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)},THREE.ShaderPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.ShaderPass,render:function(a,b,c,d,e){this.uniforms[this.textureID]&&(this.uniforms[this.textureID].value=c.texture),this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,this.clear)}});
THREE.CopyShader={uniforms:{tDiffuse:{type:"t",value:null},opacity:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float opacity;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","gl_FragColor = opacity * texel;","}"].join("\n")};
THREE.SepiaShader={uniforms:{tDiffuse:{type:"t",value:null},amount:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float amount;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 color = texture2D( tDiffuse, vUv );","vec3 c = color.rgb;","color.r = dot( c, vec3( 1.0 - 0.607 * amount, 0.769 * amount, 0.189 * amount ) );","color.g = dot( c, vec3( 0.349 * amount, 1.0 - 0.314 * amount, 0.168 * amount ) );","color.b = dot( c, vec3( 0.272 * amount, 0.534 * amount, 1.0 - 0.869 * amount ) );","gl_FragColor = vec4( min( vec3( 1.0 ), color.rgb ), color.a );","}"].join("\n")};
THREE.VignetteShader={uniforms:{tDiffuse:{type:"t",value:null},offset:{type:"f",value:1},darkness:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform float offset;","uniform float darkness;","uniform sampler2D tDiffuse;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec2 uv = ( vUv - vec2( 0.5 ) ) * vec2( offset );","gl_FragColor = vec4( mix( texel.rgb, vec3( 1.0 - darkness ), dot( uv, uv ) ), texel.a );","}"].join("\n")};
THREE.DotScreenShader={uniforms:{tDiffuse:{type:"t",value:null},tSize:{type:"v2",value:new THREE.Vector2(256,256)},center:{type:"v2",value:new THREE.Vector2(.5,.5)},angle:{type:"f",value:1.57},scale:{type:"f",value:1}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform vec2 center;","uniform float angle;","uniform float scale;","uniform vec2 tSize;","uniform sampler2D tDiffuse;","varying vec2 vUv;","float pattern() {","float s = sin( angle ), c = cos( angle );","vec2 tex = vUv * tSize - center;","vec2 point = vec2( c * tex.x - s * tex.y, s * tex.x + c * tex.y ) * scale;","return ( sin( point.x ) * sin( point.y ) ) * 4.0;","}","void main() {","vec4 color = texture2D( tDiffuse, vUv );","float average = ( color.r + color.g + color.b ) / 3.0;","gl_FragColor = vec4( vec3( average * 10.0 - 5.0 + pattern() ), color.a );","}"].join("\n")};
THREE.LuminosityHighPassShader={shaderID:"luminosityHighPass",uniforms:{tDiffuse:{type:"t",value:null},luminosityThreshold:{type:"f",value:1},smoothWidth:{type:"f",value:1},defaultColor:{type:"c",value:new THREE.Color(0)},defaultOpacity:{type:"f",value:0}},vertexShader:["varying vec2 vUv;","void main() {","vUv = uv;","gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );","}"].join("\n"),fragmentShader:["uniform sampler2D tDiffuse;","uniform vec3 defaultColor;","uniform float defaultOpacity;","uniform float luminosityThreshold;","uniform float smoothWidth;","varying vec2 vUv;","void main() {","vec4 texel = texture2D( tDiffuse, vUv );","vec3 luma = vec3( 0.299, 0.587, 0.114 );","float v = dot( texel.xyz, luma );","vec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );","float alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );","gl_FragColor = mix( outputColor, texel, alpha );","}"].join("\n")};
THREE.MaskPass=function(a,b){THREE.Pass.call(this),this.scene=a,this.camera=b,this.clear=!0,this.needsSwap=!1,this.inverse=!1},THREE.MaskPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.MaskPass,render:function(a,b,c,d,e){var f=a.context,g=a.state;g.buffers.color.setMask(!1),g.buffers.depth.setMask(!1),g.buffers.color.setLocked(!0),g.buffers.depth.setLocked(!0);var h,i;this.inverse?(h=0,i=1):(h=1,i=0),g.buffers.stencil.setTest(!0),g.buffers.stencil.setOp(f.REPLACE,f.REPLACE,f.REPLACE),g.buffers.stencil.setFunc(f.ALWAYS,h,4294967295),g.buffers.stencil.setClear(i),a.render(this.scene,this.camera,c,this.clear),a.render(this.scene,this.camera,b,this.clear),g.buffers.color.setLocked(!1),g.buffers.depth.setLocked(!1),g.buffers.stencil.setFunc(f.EQUAL,1,4294967295),g.buffers.stencil.setOp(f.KEEP,f.KEEP,f.KEEP)}}),THREE.ClearMaskPass=function(){THREE.Pass.call(this),this.needsSwap=!1},THREE.ClearMaskPass.prototype=Object.create(THREE.Pass.prototype),Object.assign(THREE.ClearMaskPass.prototype,{render:function(a,b,c,d,e){a.state.buffers.stencil.setTest(!1)}});
THREE.UnrealBloomPass=function(a,b,c,d){THREE.Pass.call(this),this.strength=void 0!==b?b:1,this.radius=c,this.threshold=d,this.resolution=void 0!==a?new THREE.Vector2(a.x,a.y):new THREE.Vector2(256,256);var e={minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter,format:THREE.RGBAFormat};this.renderTargetsHorizontal=[],this.renderTargetsVertical=[],this.nMips=5;var f=Math.round(this.resolution.x/2),g=Math.round(this.resolution.y/2);this.renderTargetBright=new THREE.WebGLRenderTarget(f,g,e),this.renderTargetBright.texture.generateMipmaps=!1;for(var h=0;h<this.nMips;h++){var i=new THREE.WebGLRenderTarget(f,g,e);i.texture.generateMipmaps=!1,this.renderTargetsHorizontal.push(i);var i=new THREE.WebGLRenderTarget(f,g,e);i.texture.generateMipmaps=!1,this.renderTargetsVertical.push(i),f=Math.round(f/2),g=Math.round(g/2)}void 0===THREE.LuminosityHighPassShader&&console.error("THREE.UnrealBloomPass relies on THREE.LuminosityHighPassShader");var j=THREE.LuminosityHighPassShader;this.highPassUniforms=THREE.UniformsUtils.clone(j.uniforms),this.highPassUniforms.luminosityThreshold.value=d,this.highPassUniforms.smoothWidth.value=.01,this.materialHighPassFilter=new THREE.ShaderMaterial({uniforms:this.highPassUniforms,vertexShader:j.vertexShader,fragmentShader:j.fragmentShader,defines:{}}),this.separableBlurMaterials=[];for(var k=[3,5,7,9,11],f=Math.round(this.resolution.x/2),g=Math.round(this.resolution.y/2),h=0;h<this.nMips;h++)this.separableBlurMaterials.push(this.getSeperableBlurMaterial(k[h])),this.separableBlurMaterials[h].uniforms.texSize.value=new THREE.Vector2(f,g),f=Math.round(f/2),g=Math.round(g/2);this.compositeMaterial=this.getCompositeMaterial(this.nMips),this.compositeMaterial.uniforms.blurTexture1.value=this.renderTargetsVertical[0].texture,this.compositeMaterial.uniforms.blurTexture2.value=this.renderTargetsVertical[1].texture,this.compositeMaterial.uniforms.blurTexture3.value=this.renderTargetsVertical[2].texture,this.compositeMaterial.uniforms.blurTexture4.value=this.renderTargetsVertical[3].texture,this.compositeMaterial.uniforms.blurTexture5.value=this.renderTargetsVertical[4].texture,this.compositeMaterial.uniforms.bloomStrength.value=b,this.compositeMaterial.uniforms.bloomRadius.value=.1,this.compositeMaterial.needsUpdate=!0;var l=[1,.8,.6,.4,.2];this.compositeMaterial.uniforms.bloomFactors.value=l,this.bloomTintColors=[new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1),new THREE.Vector3(1,1,1)],this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,void 0===THREE.CopyShader&&console.error("THREE.BloomPass relies on THREE.CopyShader");var m=THREE.CopyShader;this.copyUniforms=THREE.UniformsUtils.clone(m.uniforms),this.copyUniforms.opacity.value=1,this.materialCopy=new THREE.ShaderMaterial({uniforms:this.copyUniforms,vertexShader:m.vertexShader,fragmentShader:m.fragmentShader,blending:THREE.AdditiveBlending,depthTest:!1,depthWrite:!1,transparent:!0}),this.enabled=!0,this.needsSwap=!1,this.oldClearColor=new THREE.Color,this.oldClearAlpha=1,this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)},THREE.UnrealBloomPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.UnrealBloomPass,dispose:function(){for(var a=0;a<this.renderTargetsHorizontal.length();a++)this.renderTargetsHorizontal[a].dispose();for(var a=0;a<this.renderTargetsVertical.length();a++)this.renderTargetsVertical[a].dispose();this.renderTargetBright.dispose()},setSize:function(a,b){var c=Math.round(a/2),d=Math.round(b/2);this.renderTargetBright.setSize(c,d);for(var e=0;e<this.nMips;e++)this.renderTargetsHorizontal[e].setSize(c,d),this.renderTargetsVertical[e].setSize(c,d),this.separableBlurMaterials[e].uniforms.texSize.value=new THREE.Vector2(c,d),c=Math.round(c/2),d=Math.round(d/2)},render:function(a,b,c,d,e){this.oldClearColor.copy(a.getClearColor()),this.oldClearAlpha=a.getClearAlpha();var f=a.autoClear;a.autoClear=!1,a.setClearColor(new THREE.Color(0,0,0),0),e&&a.context.disable(a.context.STENCIL_TEST),this.highPassUniforms.tDiffuse.value=c.texture,this.highPassUniforms.luminosityThreshold.value=this.threshold,this.quad.material=this.materialHighPassFilter,a.render(this.scene,this.camera,this.renderTargetBright,!0);for(var g=this.renderTargetBright,h=0;h<this.nMips;h++)this.quad.material=this.separableBlurMaterials[h],this.separableBlurMaterials[h].uniforms.colorTexture.value=g.texture,this.separableBlurMaterials[h].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionX,a.render(this.scene,this.camera,this.renderTargetsHorizontal[h],!0),this.separableBlurMaterials[h].uniforms.colorTexture.value=this.renderTargetsHorizontal[h].texture,this.separableBlurMaterials[h].uniforms.direction.value=THREE.UnrealBloomPass.BlurDirectionY,a.render(this.scene,this.camera,this.renderTargetsVertical[h],!0),g=this.renderTargetsVertical[h];this.quad.material=this.compositeMaterial,this.compositeMaterial.uniforms.bloomStrength.value=this.strength,this.compositeMaterial.uniforms.bloomRadius.value=this.radius,this.compositeMaterial.uniforms.bloomTintColors.value=this.bloomTintColors,a.render(this.scene,this.camera,this.renderTargetsHorizontal[0],!0),this.quad.material=this.materialCopy,this.copyUniforms.tDiffuse.value=this.renderTargetsHorizontal[0].texture,e&&a.context.enable(a.context.STENCIL_TEST),a.render(this.scene,this.camera,c,!1),a.setClearColor(this.oldClearColor,this.oldClearAlpha),a.autoClear=f},getSeperableBlurMaterial:function(a){return new THREE.ShaderMaterial({defines:{KERNEL_RADIUS:a,SIGMA:a},uniforms:{colorTexture:{value:null},texSize:{value:new THREE.Vector2(.5,.5)},direction:{value:new THREE.Vector2(.5,.5)}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"#include <common>\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\t\t\t\tuniform vec2 direction;\t\t\t\t\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\t\t\t\t}\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\t\t\t\t\tfloat fSigma = float(SIGMA);\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, fSigma);\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\t\t\t\t\t\tfloat x = float(i);\t\t\t\t\t\tfloat w = gaussianPdf(x, fSigma);\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset).rgb;\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset).rgb;\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\t\t\t\t\t\tweightSum += 2.0 * w;\t\t\t\t\t}\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}"})},getCompositeMaterial:function(a){return new THREE.ShaderMaterial({defines:{NUM_MIPS:a},uniforms:{blurTexture1:{value:null},blurTexture2:{value:null},blurTexture3:{value:null},blurTexture4:{value:null},blurTexture5:{value:null},dirtTexture:{value:null},bloomStrength:{value:1},bloomFactors:{value:null},bloomTintColors:{value:null},bloomRadius:{value:0}},vertexShader:"varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",fragmentShader:"varying vec2 vUv;\t\t\t\tuniform sampler2D blurTexture1;\t\t\t\tuniform sampler2D blurTexture2;\t\t\t\tuniform sampler2D blurTexture3;\t\t\t\tuniform sampler2D blurTexture4;\t\t\t\tuniform sampler2D blurTexture5;\t\t\t\tuniform sampler2D dirtTexture;\t\t\t\tuniform float bloomStrength;\t\t\t\tuniform float bloomRadius;\t\t\t\tuniform float bloomFactors[NUM_MIPS];\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\t\t\t\t\t\t\t\tfloat lerpBloomFactor(const in float factor) { \t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\t\t\t\t}\t\t\t\t\t\t\t\tvoid main() {\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) + \t\t\t\t\t \t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) + \t\t\t\t\t\t\t\t\t\t\t\t lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\t\t\t\t}"})}}),THREE.UnrealBloomPass.BlurDirectionX=new THREE.Vector2(1,0),THREE.UnrealBloomPass.BlurDirectionY=new THREE.Vector2(0,1);
THREE.DotScreenPass=function(a,b,c){THREE.Pass.call(this),void 0===THREE.DotScreenShader&&console.error("THREE.DotScreenPass relies on THREE.DotScreenShader");var d=THREE.DotScreenShader;this.uniforms=THREE.UniformsUtils.clone(d.uniforms),void 0!==a&&this.uniforms.center.value.copy(a),void 0!==b&&(this.uniforms.angle.value=b),void 0!==c&&(this.uniforms.scale.value=c),this.material=new THREE.ShaderMaterial({uniforms:this.uniforms,vertexShader:d.vertexShader,fragmentShader:d.fragmentShader}),this.camera=new THREE.OrthographicCamera(-1,1,1,-1,0,1),this.scene=new THREE.Scene,this.quad=new THREE.Mesh(new THREE.PlaneBufferGeometry(2,2),null),this.quad.frustumCulled=!1,this.scene.add(this.quad)},THREE.DotScreenPass.prototype=Object.assign(Object.create(THREE.Pass.prototype),{constructor:THREE.DotScreenPass,render:function(a,b,c,d,e){this.uniforms.tDiffuse.value=c.texture,this.uniforms.tSize.value.set(c.width,c.height),this.quad.material=this.material,this.renderToScreen?a.render(this.scene,this.camera):a.render(this.scene,this.camera,b,this.clear)}});
var initComposer = function () {
    var parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false
    };
    var renderTarget = new THREE.WebGLRenderTarget(width, height, parameters);
    composer = new THREE.EffectComposer(renderer, renderTarget);
    composer = new THREE.EffectComposer(renderer, renderTarget);
    enablebg ? composer.addPass(renderPassBG) : composer.addPass(renderPassGlobal);
    composer.addPass(renderPass);
    _composer = dataBaseO.composer.DarkNight || dataBaseO.composer.WhiteCurtain || dataBaseO.composer.Restoring || dataBaseO.composer.Restoring || dataBaseO.composer.Pixel || dataBaseO.composer.Luminous;
    if (dataBaseO.composer.Luminous) {
        luminous.copyUniforms["opacity"].value = dataBaseO.composer.LuminousV / 50;
        composer.addPass(luminous);
    }
    if (dataBaseO.composer.DarkNight) {
        darknight.uniforms['offset'].value = dataBaseO.composer.DarkNightV;
        composer.addPass(darknight);
    }
    if (dataBaseO.composer.WhiteCurtain) {
        whitecurtain.uniforms["darkness"].value = -dataBaseO.composer.WhiteCurtainV / 15;
        composer.addPass(whitecurtain);
    }
    if (dataBaseO.composer.Restoring) {
        restoring.uniforms["amount"].value = Math.pow(((100 - dataBaseO.composer.RestoringV * 2) / 100), 3);
        composer.addPass(restoring);
    }
    if (dataBaseO.composer.Pixel) {
        pixel.uniforms["angle"].value = dataBaseO.composer.PixelV / 100;
        composer.addPass(pixel);
    }

    composer.addPass(ShaderPass);
    ShaderPass.renderToScreen = true;
};